# 트랜잭션의 동작 방식

트랜잭션을 위해 데이터베이스는 Read와 Write연산을 지원한다.

Read(X) : 데이터베이스에서 X라는 데이터를 읽은 후 트랜잭션이 실행되는 메모리의 변수 X에 값을 저장하는 연산.

Write(X) : 트랜잭션이 실행되는 메모리에 있는 변수 X의 값을 데이터베이스에 전송하여 X라는 데이터를 저장하는 연산.

트랜잭션이 동작하는 방식을 알아보기 위해 학사 시스템에서 학생 계좌를 이체하는 작업을 예로 들어보자. 트랜잭션 T1이 수행되기 전에 계좌 A에는 10,000원 계좌 B에는 20,000원이 있다고 가정하자. T1은 계좌 A에서 계좌 B로 1,000원을 이체하는 작업으로, 데이터베이스 연산을 사용하여 [계좌이체트랜잭션.png]과 같이 표현 할 수 있다.

   
[계좌이체트랜잭션.png]

![계좌이체트랜잭션](image/계좌이체트랜잭션.png)


원자성 : Write(A) 연산 도중에 DBMS의 오류로 완료하지 못하면 A에는 9,000원, 계좌 B에는 20,000이 되어 1,000원이 사라진다.
트랜잭션이 실패한다 할지라도 현실 세계의 예금이 사라지는 경우가 발생해서는 안되기 때문에 원자성 보장을 위해 완료되지 않은 트랜잭션의 중간 상태를 트랜잭션에 포함된 어떠한 연산도 반영되지 않은 상태로 되돌린다.


일관성 : 은행 업무에서 계좌 A와 B의 잔고의 합이 트랜잭션 실행 후에도 트랜잭션 수행 전과 같아야 한다. 즉 트랜잭션이 수행되기 전에 데이터베이스가 일관성을 가지고 있다면, 트랜잭션이 완료된 후에도 데이터베이스에 저장된 데이터는 다른 상태의 일관성이 유지되어야 한다.


고립성 : 동시에 복수 개의 트랜잭션 처리 시 데이터베이스가 비일관성 상태로 될 수 있다. T1에서 Write(A)연산이 수행되고, Write(B)연산이 수행되기 전 상태에서 다른 트랜잭션 T2가 두 계좌 A와 B의 잔고의 합계를 낸다면 29,000원으로 잘못된 결과를 얻게 된다. 따라서 데이터베이스는 T2의 수행을 정지시켜 여러 개의 트랜잭션이 동시에 수행되더라도 각 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 마치 독립적으로 수행되는 것과 같은 결과를 낼 수 있는 것을 보장한다.


지속성 : 트랜잭션의 실행이 성공적으로 완료되었다면, 그 후에 DBMS에 오류가 발생하더라도 변경된 값이 지속적으로 저장되어 있는 것을 보장한다. T1이 성공적으로 완료되면 데이터베이스의 계좌 A에는 9,000원, B에는 21,000이 저장된다. 이후 어떤 원인에 의해 컴퓨터 시스템에 오류가 발생하여 메모리에 있는 데이터가 삭제되더라도 트랜잭션이 완료되면 데이터가 데이터베이스의 저장장치에 기록되기 때문에 시스템이 재가동 되면 데이터베이스의 저장장치에 기록된 데이터를 읽어 데이터의 손실을 방지한다.